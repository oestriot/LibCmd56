#include "log.h"
#include "crypto/aes.h"
#include "crypto/aes_cmac.h"
#include "f00d_emu.h"

// only used to derive static data, so not really needed;
static uint8_t BIGMAC_KEY_0x345[0x20] = { 0x74, 0xC3, 0x9C, 0xA4, 0xEF, 0x4F, 0x12, 0x29, 0x15, 0xC7, 0x1E, 0xDA, 0x46, 0xC8, 0x8B, 0x55, 0xBB, 0xAD, 0x1F, 0x40, 0x33, 0xD7, 0x55, 0xCE, 0xA0, 0x56, 0x3C, 0xC3, 0x41, 0xF9, 0x2E, 0x66 };
static uint8_t BIGMAC_KEY_0x348[0x20] = { 0xC0, 0x26, 0x28, 0x14, 0x13, 0xFA, 0x46, 0x2C, 0xCD, 0xEE, 0xD4, 0xBD, 0x6D, 0x08, 0xC3, 0x7C, 0xA6, 0xC9, 0x32, 0x2A, 0xBD, 0x4C, 0x40, 0xAD, 0xE7, 0x2A, 0x0F, 0x54, 0x4F, 0x40, 0x13, 0xAD };

// these go unused, as we dont have aes-256 and these are just static data decrypted with a static key, can be skipped.
static uint8_t GCAUTHMGR_0x8001_SEED[0x10] = { 0x6F, 0x22, 0x85, 0xED, 0x46, 0x3A, 0x6E, 0x57, 0xC5, 0xF3, 0x55, 0x0D, 0xDC, 0xC8, 0x1f, 0xEB };
static uint8_t GCAUTHMGR_0x8002_SEED[0x10] = { 0xDA, 0x96, 0x08, 0xB5, 0x28, 0x82, 0x5D, 0x6D, 0x13, 0xA7, 0xAf, 0x14, 0x46, 0xB8, 0xEC, 0x08 };
static uint8_t GCAUTHMGR_0x8003_SEED[0x10] = { 0x36, 0x8B, 0x2E, 0xB5, 0x43, 0x7A, 0x82, 0x18, 0x62, 0xA6, 0xC9, 0x55, 0x96, 0xD8, 0xC1, 0x35 };
static uint8_t GCAUTHMGR_0x1_SEED[0x10]    = { 0x7F, 0x1F, 0xD0, 0x65, 0xDD, 0x2F, 0x40, 0xB3, 0xE2, 0x65, 0x79, 0xA6, 0x39, 0x0B, 0x61, 0x6D };

/*
*	derived from aes-256-ecb decrypt GCAUTHMGR_KEYID_SEED value with BIGMAC_KEY_0x345
*   incuded here because its static, calculating it every time would be slower, and would require aes-256
*/ 

static uint8_t GCAUTHMGR_0x8001_KEY[0x10] = { 0xCB, 0x80, 0x8D, 0x14, 0x02, 0x62, 0x53, 0x17, 0x25, 0x24, 0xD8, 0xA1, 0xf5, 0x1D, 0x35, 0xC7 };
static uint8_t GCAUTHMGR_0x8002_KEY[0x10] = { 0x56, 0xB6, 0x7b, 0xE1, 0x00, 0x03, 0xB4, 0x3B, 0xB8, 0x24, 0xD7, 0x06, 0xEE, 0x93, 0x59, 0x9D };
static uint8_t GCAUTHMGR_0x8003_KEY[0x10] = { 0xE8, 0xBD, 0xDA, 0xFb, 0xF4, 0xA3, 0xB9, 0x9B, 0x54, 0x56, 0x2C, 0x68, 0x21, 0xD8, 0x05, 0x1E };
static uint8_t GCAUTHMGR_0x1_KEY[0x10]    = { 0x72, 0x50, 0x6A, 0x4B, 0xA8, 0x36, 0xC8, 0x76, 0xC4, 0x48, 0x40, 0x70, 0x1F, 0x0E, 0xA1, 0x02 };
static uint8_t GCAUTHMGR_0x1_IV[0x10]     = { 0x8b, 0x14, 0xc8, 0xa1, 0xe9, 0x6f, 0x30, 0xa7, 0xf1, 0x01, 0xa9, 0x6a, 0x30, 0x33, 0xc5, 0x5b };

void derive_master_key(uint8_t* masterKey_out, uint8_t* cart_random, int key_id) {
	uint8_t* ukey;

	switch (key_id) {
		case PROTOTYPE_KEY_ID1:
			ukey = GCAUTHMGR_0x8001_KEY;
			break;
		case PROTOTYPE_KEY_ID2:
			ukey = GCAUTHMGR_0x8002_KEY;
			break;
		case PROTOTYPE_KEY_ID3:
			ukey = GCAUTHMGR_0x8003_KEY;
			break;
		case RETAIL_KEY_ID:
			ukey = GCAUTHMGR_0x1_KEY;
			break;
		default:
			LOG("invalid key id passed to derive_master_key 0x%x", key_id);
			return;
	}

	AES_CMAC_buffer_key(ukey, cart_random, 0x20, masterKey_out);
	if (key_id == 0x1) {
		AES_CBC_decrypt_buffer_key(BIGMAC_KEY_0x348, masterKey_out, 0x10, GCAUTHMGR_0x1_IV);
	}

	return;
}

/*
(unused)
void decrypt_secondary_key0(uint8_t* cart_random, int key_id, uint8_t* vita_authenticity_key, uint8_t* secondary_key0) {
	uint8_t* master_key;
	derive_master_key(master_key, cart_random, key_id);
	AES_ctx master_key_ctx;
	AES_init_ctx(&master_key_ctx, master_key);
	memcpy(secondary_key0, vita_authenticity_key, 0x10);
	decrypt_cbc_zero_iv(&master_key_ctx, secondary_key0, 0x10);
}
*/
